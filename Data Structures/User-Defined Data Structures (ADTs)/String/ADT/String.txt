Standard Definition of string :
 Anything inside the double quotes " " is called string.
C++ has character arrays (difficult to handle) and std::string (quite easy).

// std::string is a built-in class in C++.
// However , we make our own using char arrays.
// While making we should keep many things in mind like '\0' etc.

// std::string in C++ is of 32 bytes from start.
// It has 3 things in it :
// 1) char pointer * to hold data , 2) size_t , 3) capacity = 24 bytes (On 64 Bit System) , may vary for others but pointer in modern days is 8 bytes now.
// Compilers add a buffer for Small String Optimization (SSO).
// On a 64-bit system, the string object is padded to 32 bytes to keep memory alignment efficient.
// The Object itself (its data members) is on stack but data being pointed may or may not be in heap.
// If 15-22 chars then data in stack otherwise heap.

// Here in our class , the data being stored will be in heap whether any kind of length.
// The Size / Bytes of our std::string or our class String has fixed object size.
// On stack it has fixed *data , capacity and size variables.
// The thing growing its characters is in heap which is not visible to us but we can see by .size() or .length() or .capacity() methods.

// Allocator is a separate class (or struct). It is designed to be a "plug-in" component that your String class uses to do the heavy lifting of memory management.

// In the C++ Standard Library, the default one is called std::allocator. 
// If you don't provide one, std::string uses it by default. 

// A standard allocator (like std::allocator<char>) performs four main tasks:
// Allocation (allocate): Grabs raw, uninitialized memory from the heap. This is like buying a vacant lot of land.
// Construction (construct): Places an object into that memory. This is like building a house on that land.
// Destruction (destroy): Safely tears down the object (calls its destructor).
// Deallocation (deallocate): Gives the memory back to the system.
// std::string , maps, sets, vectors, dequeue , list use allocator and many more features like this.
// std::stack , queue , span , string_view don't use it.

// Use of string_view : (Available in C++ 17 only and above)
// If you have a function that takes a const std::string&, and you pass it a raw 
// C-style string ("Hello"), the compiler is forced to create a temporary std::string 
// object, which means a heap allocation and a copy.
// When you use string_view, no copy happens. It just "points" to the existing memory of the literal.

// Because it doesn't own the memory, you must ensure the "real" string stays alive as 
// long as the view is looking at it. If the original string is deleted, 
// the string_view becomes a dangling pointer.
